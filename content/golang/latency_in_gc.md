---
title: Golang 的 GC 什么时候回出现卡顿
tags:
    - Golang
    - GC
date: 2026-01-17
order: 2
---

:::[!abstract]总结：什么时候会感觉到卡顿？

1.  **高分配速率：** 业务逻辑分配内存太快，触发了大量的 **Mark Assist**。
2.  **海量对象/指针：** 堆内存中存储了数亿个小对象或复杂的指针结构（如巨大的 `map[int]*Struct`），增加了标记负担。
3.  **非抢占式循环：** 代码中存在长时间不含函数调用的 `for` 循环（在 Go 1.14 引入异步抢占后有所缓解，但在极极端情况下仍可能影响 STW 等待时间）。
4.  **系统资源枯竭：** 物理内存不足导致 Swap 开关触发，或者 CPU 满载，导致 GC 线程无法及时完成工作。
:::

Golang 的垃圾回收（GC）主要采用的是**并发三色标记清除算法（Concurrent Mark-and-Sweep）**。虽然 Go 团队一直在努力降低 GC 延迟（在现代 Go 版本中，STW 耗时通常在亚毫秒级），但在某些特定场景下，依然会出现明显的卡顿（Latency）或性能下降。

> - [ ] 并发三色标记清除算法

以下是 Golang GC 导致卡顿的主要原因和场景：

## Stop-The-World (STW) 阶段
尽管是并发 GC，但仍然有两个必须暂停所有 Goroutine 的阶段：
*   **Sweep Termination（清理终止）阶段：** 开启 GC 循环，准备标记工作。
*   **Mark Termination（标记终止）阶段：** 完成标记工作，重新扫描部分栈、关闭写屏障等。
*   **卡顿原因：** 如果活跃的 Goroutine 数量极多（成千上万），或者某些 Goroutine 无法被快速抢占（例如在进行密集的、没有函数调用的循环），会导致 STW 等待时间变长。

> - [ ] Stop-The-World
> - [ ] 为什么说没有函数调用的循环？有函数调用的有什么不同

## Mark Assist（辅助标记）机制
这是 Go 解决“分配速度快于标记速度”的机制。
*   **场景：** 当后台 GC 标记 Goroutine 来不及处理内存标记，而用户 Goroutine 仍在快速申请新内存时。
*   **表现：** 运行时会强制要求当前正在申请内存的 Goroutine 先停下来去帮忙做一部分 GC 标记工作。
*   **后果：** 用户请求的响应时间会突然变长，表现为**单次请求的延迟抖动**，而非整个进程挂起。

> - [ ] Mark Assist

## 写屏障（Write Barrier）开销
*   **场景：** 在 GC 的并发标记阶段，为了保证三色不变性，所有的指针修改都会触发写屏障。
*   **影响：** 写屏障会增加 CPU 的额外开销。对于写操作极其密集的应用（如大量的 Map 更新或指针赋值），会导致业务逻辑变慢，吞吐量下降。

> - [ ] 写屏障

## 堆压力过大与 GOGC 设置
*   **频繁触发：** 如果 `GOGC`（默认 100）设置得较小，或者堆内存接近系统上限，GC 会频繁启动。
*   **资源竞争：** GC 本身需要消耗大量的 CPU 资源（通常占用 `GOMAXPROCS` 的 25%）。在系统 CPU 负载已经很高的情况下，GC 的介入会导致竞争更加激烈，从而产生卡顿感。

## 扫描大对象或深层次指针
*   **大对象扫描：** 即使是并发标记，扫描一个拥有数百万个指针的超大 Slice 或 Map 依然是沉重的负担。
*   **卡顿点：** 虽然扫描是并发的，但它会长时间占用 CPU 核心，影响其他 Goroutine 的调度效率。

## 内存碎片与清理（Sweep）
*   **背景：** 清理是并发进行的，但如果内存碎片严重，分配器（mspan）在寻找合适空闲空间时会变慢。
*   **表现：** 分配内存的操作（`mallocgc`）耗时增加。

## 优化建议
*   **对象复用：** 使用 `sync.Pool` 减少分配频率。
*   **指针优化：** 尽量使用非指针类型（如 `map[int]int` 优于 `map[int]*int`），因为 GC 不会扫描不含指针的变量。
*   **调整 GOGC：** 根据内存容量适当调大 `GOGC` 值，减少 GC 触发频率（Go 1.19+ 推荐使用 `GOMEMLIMIT`）。
*   **避免大 Map：** 对于数千万级别的 key-value 存储，可以考虑使用非堆内存存储（如 `off-heap`）或分布式缓存。
