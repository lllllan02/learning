---
title: A Guide to the Go Garbage Collector
tags:
    - Golang
    - GC
date: 2026-01-17
order: 1
---

> [A Guide to the Go Garbage Collector | Go 官方文档](https://tip.golang.org/doc/gc-guide)

## 一、基础概念

### 垃圾回收 GC

自动回收内存的另一个术语是垃圾回收。从广义上讲，

:::[!info] 垃圾回收器（garbage collection，简称 GC）
是一个系统，**它通过识别内存中哪些部分不再需要，来代表应用程序回收内存**。
:::

### 对象与指针

- 对象是一块动态分配的内存，其中包含一个或多个Go值。
- [[/golang/gc/pointer|指针]]是引用对象内任何值的内存地址（这自然包括 `*T` 形式的 Go 值，也包括内置 Go 值的部分。字符串、切片、通道、映射和接口值都包含垃圾回收器（GC）必须追踪的内存地址）。

### 对象图与根

- 对象及指向其他对象的指针构成**对象图**。
- [[/golang/gc/root|根节点]]是指那些标识着程序肯定在使用的对象的指针。根节点的两个例子是局部变量和全局变量。
> 无法肯定被使用的是指那些[[/golang/gc/lifetime|无法确定生命周期]]的对象

## Go 值存储在哪里

### 栈分配

例如，存储在局部变量中的非指针Go值很可能根本不会由Go的垃圾回收器（GC）管理，相反，Go会安排分配与创建该值时的[词法作用域](https://tip.golang.org/ref/spec#Declarations_and_scope)相关联的内存。一般来说，这比依赖垃圾回收器更高效，<u>因为Go编译器能够预先确定该内存何时可以被释放，并生成相应的机器指令来进行清理</u>。通常，我们将以这种方式为Go值分配内存称为“栈分配”，因为这些空间是**存储在goroutine栈上的**。

:::[!question] 为什么就能预先确定何时可以被释放？
在编译阶段，Go 编译器会通过静态分析来追踪每一个变量的生命周期。它会问一个关键问题：“这个变量在函数返回后，还会被外部引用吗？”

如果变量只在函数内部使用（例如局部变量，且没有把它的指针传给函数外部），编译器就确定它的生命周期在函数结束时也随之结束。
:::

### 堆逃逸

那些由于编译器[[/golang/gc/lifetime|无法确定其生命周期]]而不能以这种方式分配内存的值，被称为“逃逸到堆上”。

“堆”可以看作是内存分配的一个万能容器，当 Go 语言的值需要被放置在某个地方时，堆就派上用场了。在堆上分配内存的行为通常被称为 **“动态内存分配”**，因为编译器和运行时对于这些内存的使用方式以及何时可以被清理，几乎无法做出任何假设。这就是垃圾回收器（GC）的用武之地：它是一个专门用于识别并清理动态内存分配的系统。

:::[!info] 堆逃逸的传递性
如果一个 Go 值的引用被写入另一个已确定会逃逸的 Go 值中，那么该值也必须逃逸。
:::

有关如何确定哪些值会发生逃逸、哪些不会的更多详细信息，请参见[消除堆分配](https://tip.golang.org/doc/gc-guide#Eliminating_heap_allocations)部分

## GC 工作机制

### 追踪垃圾回收

Go的垃圾回收器采用==标记-清除技术==，这意味着为了跟踪其进度，垃圾回收器还会将遇到的值标记为活跃状态。追踪完成后，垃圾回收器会遍历堆中的所有内存，并使所有未被标记的内存可供分配。这个过程称为清除。

:::[!tip] 非移动 GC
与移动 GC（将对象移至新内存区域并留下转发指针）不同，Go GC 为非移动 GC，不移动对象。

- [ ] 无分代、并发、三色标记清除（Mark-and-Sweep） 算法
:::

### GC 周期

Go语言的垃圾回收大致分为两个阶段：标记阶段和清除阶段。

- 标记阶段：GC 从根开始遍历对象图，将遇到的活跃值标记为 “存活”。
- 清除阶段：追踪完成后，GC 遍历堆中所有内存，释放未标记的内存供重新分配。

**清除操作必须与标记操作完全分离。**

<u>在所有内存都被追踪完毕之前，无法释放内存以供重新分配，因为可能仍有未扫描的指针使某个对象保持存活状态。</u>

垃圾回收器会在清除、关闭和标记这三个阶段不断循环，这就是所谓的垃圾回收周期。就本文档而言，可以认为垃圾回收周期**始于清除阶段**，接着是关闭阶段，然后是标记阶段。

:::[!question] 没有标记，怎么清除呢？
Go 采用的是**并发清除（Concurrent Sweep）**。当一个 GC 标记阶段结束时，它并不会立即同步地把所有垃圾都清理掉。相反，它会把清理工作“推迟”到下一个周期开始时，或者在程序运行过程中按需（Lazy）进行。

<u>因此，当新的 GC 周期被触发时，它的第一件事往往是确保上一个周期留下的清除工作已经彻底完成。</u>
:::

## 其他更多晦涩难懂的东西

文章太长太难懂了，如果想要了解更多，可以从[这里](https://tip.golang.org/doc/gc-guide#The_GC_cycle)继续看