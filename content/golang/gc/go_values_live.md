---
title: Go 值存储在哪里
tags:
    - Golang
    - Value
date: 2026-01-18
order: 104
---

在 Go 语言中，值（Value）的存储位置主要取决于其**类型**、**用途**以及**生命周期**。编译器会根据“逃逸分析”（Escape Analysis）来决定将值放在哪里，以实现性能和内存管理的平衡。

> - [ ] 逃逸分析

完整来看，Go 的值主要存储在以下四个地方：

## 寄存器 (Registers)
这是速度最快的地方。
*   **用途：存储最频繁使用的变量、临时计算结果**。
*   Go 1.17+：引入了基于寄存器的调用约定（Register-based calling convention）。现在，<u>函数的参数和部分返回值会优先尝试通过寄存器传递，而不是全部通过内存（栈）</u>。
*   例子：简单的整数运算、循环变量、小型的指针或结构体。

## 栈 (Stack)
栈是分配效率最高、管理最简单的内存区域。
*   **用途：存储局部变量、函数参数和返回值**（[[/golang/gc/func_param_and_return_live|函数参数和返回值到底存储在哪？]]）。
*   特点：
    *   生命周期明确：随函数调用而创建，随函数返回而销毁（LIFO，后进先出）。
    *   管理成本低：只需移动栈指针，无需 GC 介入，清理极快。
    *   动态扩展：Go 的协程（Goroutine）栈初始很小（通常 2KB），会根据需要自动增长或收缩。
*   例子：在一个函数内部定义的非逃逸变量（如 `x := 10`）。


## 堆 (Heap)
堆是存储动态分配内存的地方，也是垃圾回收器（GC）工作的核心区域。
*   **用途：存储那些生命周期无法在编译期确定或体积巨大的值**。
*   特点：
    *   [[/golang/gc/lifetime|无法确定生命周期]]：值可能在函数结束后继续存在。
    *   GC 管理：需要由垃圾回收器定期扫描、标记并清理，会产生一定的 CPU 和延迟成本。
    *   逃逸分析决定：如果一个局部变量的地址被返回到了函数外部，或者被存入了一个生命周期更长的对象中，编译器就会将其分配到堆上，这被称为“逃逸到堆”。
*   例子：全局变量、返回指针的局部变量、动态大小的 `map`、`slice` 的底层数组、`channel`。

## 静态存储区 / 数据段 (Data Segment & BSS)
这是在程序启动时就分配好的内存，直到程序运行结束。
*   **用途：存储全局变量和只读数据**。
*   分类：
    *   .data：已初始化的包级变量（非零值）。
    *   .bss：初始化为零值的包级变量。
    *   .rodata：只读数据段，存储字符串内容、类型描述符（Type descriptors）、接口转换表（itab）等。
*   例子：`var GlobalVar = 100`，`const PI = 3.14`，代码中的字符串 `"Hello World"`。

:::[!question] 局部常量也会一直存储吗？
局部常量只是作用域仅在函数内部，但因为编译器的原因，两者的生命周期是相同的，都会一直存储到程序运行结束。
:::

---

## 核心逻辑：编译器如何选择？

Go 编译器通过 **逃逸分析（Escape Analysis）** 进行决策。你可以通过 `go build -gcflags="-m"` 命令观察这个过程。

| 情况 | 存储位置 | 原因 |
| :--- | :--- | :--- |
| 变量仅在函数内部使用且体积小 | **栈** | 效率最高，随函数返回自动清理。 |
| 变量的地址被函数返回 | **堆** | 函数返回后，栈内存被回收，必须存在堆上才能保证安全。 |
| 变量体积巨大（如超大数组） | **堆** | 防止栈溢出。 |
| 变量被写入了一个逃逸的变量中 | **堆** | 关联性导致其必须逃逸。 |
| 闭包引用的变量 | **堆** | 闭包可能在函数返回后被调用。 |

## 总结
你可以把存储位置想象成不同的柜子：
- **寄存器**：手里正拿着的工具。
- **栈**：工作台上随手拿取的常用零件（用完即收）。
- **堆**：共用的仓库（需要有人定期清理，否则会满）。
- **静态存储区**：墙上挂着的、永远不动的参考图纸。