---
title: GC 中的指针概念
tags:
    - Golang
    - GC
    - 指针
date: 2026-01-17
order: 101
---

这句话是 Go 官方文档中关于垃圾回收（GC）机制非常核心的一段描述。我们可以从以下三个层面来深度理解它：

## 广义的“指针”概念
在普通的编程理解中，我们常把指针等同于显式声明的 `*T` 类型（如 `*int`, `*Struct`）。

但这句话告诉我们，**对于 Go 的垃圾回收器（GC）来说，“指针”是一个更广义的概念**：只要一个变量内部存储了一个“指向另一块内存区域的地址”，GC 就会把它当做指针来对待。

## 显式指针 vs. 隐藏的内部指针
这句话特别强调了“内置 Go 值的部分”。很多你看起来不是指针的类型，其底层结构体里其实都藏着指针：

### 切片 (Slice)

当你传递一个 `[]int` 时，虽然它不是 `*[]int`，但它内部包含一个指向底层数组的指针。GC 必须追踪这个 `array` 地址，否则底层数组会被误认为没人使用而被回收。

```go
type slice struct {
    array unsafe.Pointer // 这是一个指针，指向底层数组
    len   int
    cap   int
}
```

### 字符串 (String)

字符串内部也藏着一个指向实际字符数据的指针。

```go
type stringStruct struct {
    str unsafe.Pointer // 指向底层字节数组的指针
    len int
}
```

### 映射 (Map) 和 通道 (Channel)

在 Go 内部，`map` 和 `chan` 本质上就是指向复杂结构体的指针（这就是为什么你可以直接传递它们而不需要取地址 `&`）。

### 接口 (Interface)

接口类型持有着指向数据和类型的双重指针。

```go
type iface struct {
    tab  *itab          // 指向类型信息的指针
    data unsafe.Pointer // 指向具体数值的指针
}
```

## 为什么“GC 必须追踪”这些地址？
Go 的垃圾回收器是**追踪式（Tracing）GC**，它通过“对象图”来工作：

1.  **从根开始**：GC 从全局变量、栈上的局部变量开始扫描。
2.  **寻找引用**：它查看这些变量里的每一个字节。如果发现某个字节存的是一个地址（即指针），它就会顺着这个地址去找下一个对象。
3.  **标记存活**：只有被这些显式或隐式指针“钩住”的对象，才会被标记为“存活”，不会被清理。

**总结理解：**
这句话的意思是：**不要被变量的表现形式迷惑。** 无论是一个明确的指针变量 `*int`，还是一个看起来像普通值的 `slice` 或 `interface`，它们内部携带的内存地址都是 GC 构建“存活对象网”的关键节点。GC 的工作量很大一部分就在于扫描并追踪这些隐藏在各种数据结构内部的地址。